<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <title>Sector Analysis - Impacts of supply chain</title>
  <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="https://unpkg.com/tabulator-tables@5.2.7/dist/css/tabulator.min.css" rel="stylesheet">
  <script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.2.7/dist/js/tabulator.min.js"></script>

  <script type="text/javascript" src="https://model.earth/localsite/js/localsite.js?showheader=true&showsearch=true"></script>
  <script src="../dist/useeio.js"></script>
  <style>
    #table {
      margin: 20px 0;
      height: auto !important; /* Override fixed height */
    }
    .tabulator-cell {
      white-space: normal;
      overflow: visible;
      padding: 8px;
    }
    .tabulator .tabulator-header .tabulator-col {
      background-color: #f4f4f4;
    }
    /* Add these rules to remove empty space */
    .tabulator-tableholder {
      height: auto !important;
      min-height: 0 !important;
    }
    .tabulator {
      height: auto !important;
    }
  </style>
</head>

<body>
  <div style="padding-left:60px;padding-right:18px;">
    <div style="margin-bottom:10px">
        <a id="footprintLink" href="./" >State Impact Reports</a>
    </div>
    <div id="relocatedStateMenu"></div>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <p id="info" style="margin: 0;">Loading ...</p>
        <select id="number-format-select" style="margin-left: 10px;">
            <option value="simple" selected>simple</option>
            <option value="full">full</option>
            <option value="scientific">scientific</option>
        </select>
    </div>
    <div id="table"></div>
    <a href="#" id="showAllLink" style="display:block; margin: 10px 0 20px 0;">Show all rows</a>
    <!-- <div id="chord-diagram" style="width: 800px; height: 800px; margin: 20px auto;"></div>  --> 
  </div>
  
  <script src="./config.js"></script>
  <script>
    // Add at the top level of the script, outside any function
    let isShowingAllRows = false;
    let table;
    let currentData = null; // Add this to track current data state
    let allResults = null; // Add this to store full dataset

    // creating function chartData to store the data for the chord diagram
    let chartData = {
        nodes: [],
        links: []
    };

    document.addEventListener('hashChangeEvent', hashChangedUseeio, false);
    function hashChangedUseeio() {
      console.log("URL hash changed");
      model = getModel();
      isShowingAllRows = false;
      currentData = null;
      
      // Reset format to simple when state changes
      const formatSelect = document.getElementById('number-format-select');
      formatSelect.value = 'simple';
      
      // Reset show all link visibility and state before loading new state
      const showAllLink = document.getElementById('showAllLink');
      showAllLink.style.display = 'block';
      isShowingAllRows = false;
      
      main();
    }
    async function main() {
      let hash = getUrlHash();
      const info = document.getElementById("info");
      const demandId = await model.findDemand({
        system: "Complete",
        type: "Consumption",
      });
      if (!demandId) {
        info.textContent = "Failed to load demand";
        return;
      }

      const sectors = await model.sectors();
      const i = Math.round(Math.random() * (sectors.length - 1));
      const sector = sectors[i];
      info.textContent = `Analyzing sector '${sector.name}' based on ${demandId}`;

      const analysis = await useeio.SectorAnalysis.of(model, sector, demandId);
      const indicators = await model.indicators();

      const total = await analysis.getSupplyChainImpacts(indicators);
      const byIndicator = {};
      for (const indicator of indicators) {
        byIndicator[indicator.code] = await analysis.getSupplyChainImpacts(indicator);
      }
      const results = [];
      for (const sector of sectors) {
          // Store raw values for proper sorting
          const rawTotal = Math.abs(total[sector.index]);
          const result = {
              sector: `${sector.code} - ${sector.name}`,
              total: rawTotal,
              totalRaw: rawTotal, // Add raw value for sorting
              sortValue: rawTotal // Explicit sort value
          };
          indicators.forEach(i => {
              const value = byIndicator[i.code][sector.index];
              result[i.code] = value;
          });
          results.push(result);
      }

      // Sort results by total impact
      results.sort((a, b) => b.sortValue - a.sortValue);

      // Store all results for later use
      allResults = results.sort((a, b) => b.sortValue - a.sortValue);
      // Take top 10 initially
      const sortedResults = allResults.slice(0, 10);

      // Replace the existing formatNumber function with:
      function formatNumber(value, formatType) {
          // Handle true zero or undefined values
          if (value === 0 || !value) {
              return '0.0000';
          }
          
          switch(formatType) {
              case 'simple': {
                  // Update threshold to 1e-33 for decillionth
                  if (Math.abs(value) < 1e-33) {
                      return value.toExponential(4);
                  }
                  
                  const expSimple = value.toExponential();
                  const [mantissaSimple, exponentSimple] = expSimple.split('e');
                  const power = parseInt(exponentSimple);
                  
                  // Function to convert scientific notation to word form
                  function getNumberWord(power) {
                      const words = {
                          0: '',
                          3: 'thousand',
                          6: 'million',
                          9: 'billion',
                          12: 'trillion',
                          15: 'quadrillion',
                          18: 'quintillion',
                          21: 'sextillion',
                          24: 'septillion',
                          27: 'octillion',
                          30: 'nonillion',
                          33: 'decillion',
                          '-1': 'tenth',
                          '-2': 'hundredth',
                          '-3': 'thousandth',
                          '-6': 'millionth',
                          '-9': 'billionth',
                          '-12': 'trillionth',
                          '-15': 'quadrillionth',
                          '-18': 'quintillionth',
                          '-21': 'sextillionth',
                          '-24': 'septillionth',
                          '-27': 'octillionth',
                          '-30': 'nonillionth',
                          '-33': 'decillionth'
                      };

                      // Handle numbers with no exponent (e+0) or small positive exponents
                      if (power >= 0 && power < 3) {
                          const adjustedValue = parseFloat(mantissaSimple) * Math.pow(10, power);
                          return adjustedValue.toFixed(4);
                      }

                      // For extremely small numbers beyond decillionth
                      if (power < -33) {
                          return value.toExponential(4);
                      }

                      // For small numbers, use exact power if available
                      if (power < 0 && power > -3) {
                          const word = words[power];
                          if (word) {
                              const adjustedMantissa = parseFloat(mantissaSimple) * Math.pow(10, -power);
                              return `${adjustedMantissa.toFixed(4)} ${word}`;
                          }
                      }

                      // For other numbers, use the ceiling of negative power/3 or floor of positive power/3
                      const absExponent = Math.abs(power);
                      let nearestPower;
                      if (power < 0) {
                          // For negative powers, we need to round up to the next power of 3
                          nearestPower = Math.ceil(absExponent / 3) * 3;
                      } else {
                          // For positive powers, keep using floor
                          nearestPower = Math.floor(absExponent / 3) * 3;
                      }
                      
                      const word = words[power > 0 ? nearestPower : -nearestPower];
                      
                      if (!word) return value.toExponential(4);
                      
                      // Adjust mantissa based on difference from nearest power
                      const powerDiff = nearestPower - absExponent;
                      const adjustedMantissa = parseFloat(mantissaSimple) * Math.pow(10, powerDiff);
                      return `${adjustedMantissa.toFixed(4)} ${word}`;
                  }
                  
                  return getNumberWord(power);
              }
              case 'full': {
                  // Lower the threshold for switching to exponential
                  if (Math.abs(value) < 1e-18) {
                      return value.toExponential(4);
                  } else {
                      return new Intl.NumberFormat('en-US', {
                          minimumFractionDigits: 4,
                          maximumFractionDigits: 18 // Increased precision
                      }).format(value);
                  }
              }
              case 'scientific': {
                  const expSci = value.toExponential();
                  const [mantissaSci, exponentSci] = expSci.split('e');
                  const formattedMantissa = parseFloat(mantissaSci).toFixed(4);
                  return `${formattedMantissa} Ã— 10<sup>${parseInt(exponentSci)}</sup>`;
              }
              default:
                  return value.toString();
          }
      }

      // function to generate chord data
      // This function creates the data structure for the chord diagram
      function generatechartData(sectors, indicators, total, byIndicator) {
          const nodes = [
              // Add sectors as nodes, i.e. arrays of all elements
              ...sectors.map(s => ({
                  id: s.code,
                  name: s.name,
                  type: 'sector',
                  group: 1
              })),
              // Add indicators as nodes
              ...indicators.map(i => ({
                  id: i.code,
                  name: i.name || i.code,
                  type: 'indicator',
                  group: 2
              }))
          ];

          const links = [];
          sectors.forEach(sector => {
              indicators.forEach(indicator => {
                  const value = Math.abs(byIndicator[indicator.code][sector.index]);
                  if (value > 0) {
                      links.push({
                          source: sector.code,
                          target: indicator.code,
                          value: value
                      });
                  }
              });
          });

          return {
              nodes: nodes,
              links: links
          };
      }

      // Create initial table with sorted data
      function initializeTable(formatType) {
          const tableConfig = {
              data: isShowingAllRows ? allResults : sortedResults,
              layout: "fitColumns",
              initialSort: [{column: "sortValue", dir: "desc"}], // Use sortValue for initial sorting
              columns: [
                  { 
                      title: "Sector", 
                      field: "sector", 
                      width: 300,
                      formatter: "html",
                      headerSortStartingDir: "desc", // Set default sort direction to descending
                      headerClick: function(e, column) {
                          if (!isShowingAllRows) {
                              isShowingAllRows = true;
                              table.setData(allResults);
                              showAllLink.style.display = 'none';
                          }
                      }
                  },
                  { 
                      title: "Total Score", 
                      field: "total",
                      width: 180,
                      sorter: "number", // Add numeric sorter
                      sortField: "totalRaw", // Use raw value for sorting
                      formatter: function(cell) {
                          return formatNumber(cell.getValue(), formatType);
                      },
                      headerSortStartingDir: "desc", // Set default sort direction to descending
                      headerClick: function(e, column) {
                          if (!isShowingAllRows) {
                              isShowingAllRows = true;
                              table.setData(allResults);
                              showAllLink.style.display = 'none';
                          }
                      }
                  }
              ]
          };

          // Modify indicator columns to include descending sort direction
          indicators.slice(0, 10).forEach(indicator => {
              tableConfig.columns.push({
                  title: indicator.code,
                  field: indicator.code,
                  width: 160,
                  sorter: "number", // Add numeric sorter
                  headerSortStartingDir: "desc", // Set default sort direction to descending
                  formatter: function(cell) {
                      return formatNumber(cell.getValue(), formatType);
                  },
                  headerClick: function(e, column) {
                      if (!isShowingAllRows) {
                          isShowingAllRows = true;
                          table.setData(allResults);
                          showAllLink.style.display = 'none';
                      }
                  }
              });
          });

          return new Tabulator("#table", tableConfig);
      }

      let isShowingAllRows = false;

      // Initialize table with simple format by default
      let table = initializeTable('simple');
      
      // Set initial data state
      currentData = sortedResults;

      // Modify the format change listener
      const formatSelect = document.getElementById('number-format-select');
      formatSelect.addEventListener('change', function() {
          const currentFormat = this.value;
          table.destroy();
          table = initializeTable(currentFormat);
          
          // Always use the correct dataset based on state
          if (isShowingAllRows) {
              table.setData(allResults);
          } else {
              table.setData(sortedResults);
          }
          
          // Always update link visibility based on state
          document.getElementById('showAllLink').style.display = 
              isShowingAllRows ? 'none' : 'block';
      });

      // Modify the show all link handler
      const showAllLink = document.getElementById('showAllLink');
      showAllLink.addEventListener('click', function(e) {
          e.preventDefault();
          isShowingAllRows = true;
          table.setData(allResults);
          this.style.display = 'none';
          
          setTimeout(() => {
              table.scrollToRow(table.getRows()[table.getRows().length - 1], "bottom", true);
          }, 100);
      });

      // Ensure link is visible for new state data
      showAllLink.style.display = 'block';
      currentData = sortedResults;
      isShowingAllRows = false;

      // Updating the main() function to generate chord data
      chartData = generatechartData(sectors, indicators, total, byIndicator);
      
      // Console logging structure for debugging
      console.log('Chord data generated:', chartData);

    }
    main();

  </script>

</body>
</html>